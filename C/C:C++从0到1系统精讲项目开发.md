### 第10章 C++结构体、共同体、枚举

10-1 结构体的基本概念

```c++
int main(){
    struct st_girl{
        char name_en[21];
        string name;
        int age;
        double weight;
        char sex;
        bool zy;
    };
    // 创建结构体变量
    struct st_girl stgirl;
    // 清空结构体
    memset(&stgirl, 0, sizeof(stgirl))
    bzero(&stgirl, sizeof(stgirl))
    // 复制结构体
    struct st_girl stgirl1;
    stgirl1 = stgirl;
    cout << "姓名：" << stgirl.name << endl;
}
```

10-2 结构体指针

```c++
struct st_girl girl = {"xxx", 26, 33, "x", true};
struct st_girl *pst = &girl;
// 通过结构体指针访问结构体成员
cout << "姓名：" << (*pst).name << endl;
cout << "姓名：" << pst->name << endl;
```

10-3 结构体数组

```c++
struct st_gril girls[3];
memset(girls, 0, sizeof(girls))
strcpy(girls[0].name, "xx");
girls[0].age = 25;
girls[0].weight = 45;
girls[0].sex = "X";
girls[0].yz = true;
// C++11标准的语法
girls[1] = {"xx", 2, 4, "X", false};
girls[2] = {"xx", 2, 4, "X", false};
```

10-4 结构体嵌入数组和结构体

```c++
struct st_girl{
    int score[3];
    char name_en[21];
    string name;
    int age;
    double weight;
    char sex;
    bool zy;
};
struct gril;
for(int i = 0; i < 3; i++) gril.score[i] = 100 + i;
```

10-5 结构体中的指针

没有动态分配内存之前，可以用memset()函数清空结构体；动态分配内存之后，不能用memset()函数

10-6 简单链表

```c++
struct st_girl{
    int no;
    string name;
    struct st_girl* next;
}
int main(){
    // head头指针、tail尾指针、tmp临时指针
    st_girl *head = nullptr, *tail = nullptr, *tmp = nullptr;
    // 分配第一个节点
    tmp= new st_girl;
    // tmp->no = 1;
    // tmp->name = "xxx";
    // tmp->next = nullptr;
    *(tmp) = {1, "xxx", nullptr};
    tmp = new st_girl({1, "xxx", nullptr});
    head = tail = tmp;
    
    tmp = new st_girl({2, "xxx", nullptr});
    tail->next = tmp;
    tail = tmp;
    
    tmp = new st_girl({3, "xxx", nullptr});
    tail->next = tmp;
    tail = tmp;
    
    // 遍历链表
    tmp = head;
    while(tmp != nullptr){
        cout << "姓名：" << tmp.name << endl;
        tmp = tmp->next;
    }
    // 释放链表
    while(head != nullptr){
        tmp = head;
        head = head->next;
        delete tmp;
    }
}
```

10-7 共同体

```c++
union udata{
    int a;
    double b;
    char c[21];
}
udata data;
cout << "sizeof(data)=" << sieof(data) << endl;
cout << "data.a的地址是=" << (void*)&data.a << endl;
cout << "data.b的地址是=" << (void*)&data.b << endl;
cout << "data.c的地址是=" << (void*)&data.c << endl;
data.a = 3;
data.b = 8.8;
strcpy(data.c, "我是xxx");
cout << "data.a" << data.a <<endl;
cout << "data.b" << data.b <<endl;
cout << "data.c" << data.c <<endl;
```

10-8 枚举

```c++
enum colors{ red=0, yellow=1, blue=2, other=3 };
colors cc = red;
switch(cc){
    case red: cout << "红色.\n"; bradk;
    case yellow: cout << "红色.\n"; bradk;
    case blue: cout << "红色.\n"; bradk;
    default: cout << "红色.\n"; bradk;
}
```



### 第11章 C++引用

11-1 引用的基本概念

```c++
int a = 3;
int& ra = a;
int* const rb = &a;	// 指针常量
cout << "a的地址是：" << &a << " a的值是：" << a << endl;
cout << "ra的地址是：" << &ra << " ra的值是：" << ra << endl;
cout << "rb的地址是：" << &rb << " rb的值是：" << rb << endl;
```

11-2 引用的本质

11-3 引用用于函数的参数

11-4 引用的形参和const_

11-5 引用用于函数的返回值

11-6 各种形参的使用场景



### 第12章 C++函数重载、内联函数

12-1 函数的默认参数

12-2 函数的重载的基本概念

12-3 函数的重载的细节

12-4 内联函数



第13章 高质量作业实践-C++常规题

13-1 如何掌握一门编程语言

13-2 选出妃子、宫女和嬷嬷

13-3 根据数字判断月份

13-4 循环计数

13-5 循环选数

13-6 玩转字符

13-7 计算字符串的长度

13-8 显示字符串中的字符

13-9 字符串反转 

13-10 二维数组的应用

13-11 把整数转换成字符串

13-12 把字符串转换成整数

13-13 实现strcpy()和strncpy()函数

13-14 实现strcat()和strncat()

13-15 实现strchr()和strrchr()

13-16 实现strcmp()和strncmp()

13-17 实现strstr()

13-18 删除字符串右边指定的字符

13-19 删除字符串左边指定的字符

13-20 删除字符串中间的字符串

13-21 统计字符串的字数

13-22 拆分字符串

13-23 解析xml字符串（上）

13-24 解析xml字符串（下）

13-25 随机数

13-26 随机发牌



### 21-STL容器



### 22-STL算法

STL算法for_each

STL算法find_if

STL算法sort

STL算法总结



### 23-智能指针

智能指针unique_ptr基础

智能指针unique_ptr更多技巧

智能指针shared_ptr

智能指针的删除器

智能指针weak_ptr



### 24-文件操作

文件操作-写入文本文件

文件操作-读取文本文件

文件操作-写入二进制文件

文件操作-读取二进制文件

文件操作-更多细节

文件操作-fstream类

文件操作-随机存取

文件操作-缓冲区和流状态



### 25-异常、断言

C++异常

如何避免异常

C++断言



### 26-C++11新标准

C++11新标准

委托构造和继承构造

lambda函数

右值引用

移动语义

完美转发

可变参数模板

时间操作chrono库



### 27-C++11线程

创建线程

线程资源的回收

this_thread的全局函数

call_once函数

native_handle函数

线程安全

互斥锁

条件变量-生产消费者模型

生产消费者模型代码分析

原子类型atomic



### 28-可调用对象的绑定器和包装器

可调用对象

包装器function

绑定器bind

可变函数和参数

回调函数的实现

如何取代虚函数



### 
