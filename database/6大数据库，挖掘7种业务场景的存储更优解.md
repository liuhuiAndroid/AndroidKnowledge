### 第1章 如何用更优的数据存储方案，打造更稳定的架构？

##### 没有“万能”的技术手段，只有适合业务场景的解决方案

1. 存储设计使用不止是CRUD
2. 优秀的存储影响到整个业务项目
3. 大部分的应用场景属于IO密集型场景
4. 瓶颈问题：架构瓶颈往往发生在存储上
5. 应用无状态易扩展，存储有状态难扩展

数据库

1. MySQL
   - 关系型数据库
   - 适合需要ACID事务及数据稳定性要求的场景
2. ElasticSearch
   - 搜索非关系型数据库
   - 适合需要全文搜索或语义关联搜索的场景
3. HBase
   - 列式非关系型数据库
   - 适合大数据量半结构化/非结构化，数据读写且查询维度单一的场景
4. Redis
   - 缓存非关系型数据库
   - 适合需要高性能KV读取且可以容忍数据丢失的场景
5. Neo4j
   - 图非关系型数据库
   - 适合需要实体间构建多维度关联关系的场景
6. MongoDB
   - 文档式非关系型数据库
   - 适合半结构化/非结构化，数据读写且有多维度查询的场景

##### 服务端架构常见的分层方案

1. 网关层：服务接入网络层，一般分为F5，Nginx，LVS等
2. 应用层：具体的应用服务，一般采用单体应用/微服务框架搭建
3. 存储层：中心化的数据管理与落地服务

##### 为什么要做服务端架构分层

1. 面向的问题不同：网关层管网络，应用层管业务，存储层管数据
2. 各司其职：运维与后端开发的分工
3. 灵活性：部署隔离，架构灵活

##### 为什么存储数据库在架构分层中那么重要

1. 有状态服务与无状态服务的巨大行为差异
2. CPU密集型与IO密集型服务的差异
3. 架构设计中的瓶颈与短板效应

##### 数据库存储的瓶颈与短板效应

1. MySQL 单表数据库超百万查询慢，超千万查不动了
2. Redis崩溃后数据没了
3. 多维社交关系表关联太多了查不出来

##### 为什么互联网没有万能的解决方案

1. 算力取舍：空间换时间，时间换空间
2. 一致性取舍：CAP 和BASE 理论
3. 管理模式取舍：中心化及去中心化建设

##### 数据库解决方案不仅仅是CRUD那么简单



### 第2章 社交新零售业务场景的演进与架构方案设计

##### 全局视角看问题，实现全景的技术支撑架构

技术架构拆分

1. 模块拆分
2. 存储选型

##### 高效部署之容器化利器Docker

##### 使用docker解决mysql的高效部署	

Docker Engine 可以配置 Docker 代理

```json
{
	"registry-mirrors": [
		"https://hub-mirror.c.163.com",
    "https://docker.mirrors.ustc.edu.cn",
    "https://registry.docker-cn.com"
	]
}
```

```shell
docker pull docker/getting-started:latest
# 访问 http://localhost:8001/tutorial/
docker run -d -p 8001:80 docker/getting-started
docker pull mysql:latest
docker run -itd --name mysql-social -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:latest
docker exec -it mysql-social bash
mysql -uroot -p
alter user 'root'@'%' identified with mysql_native_password by '123456';
flush privileges;
```

##### SpringBoot与Mybatis Plus组合

##### Mybatis Plus基础能力搭建用户模块

##### Mybatis Plus进阶，高效的ORM代码实现

乐观锁和悲观锁



### 第3章 发挥Mysql选型优势，构建新零售核心门店与商品能力

##### Mysql选型优劣势

##### Mysql如何提供事务_索引_读写的基础能力

##### Mysql高性能配置-读写能力提升的秘诀

#####  领域驱动设计-领域模型的重要性

 领域驱动设计DDD

- 基于领域职责，应用能力，安全边界，技术异构，效率考虑领域拆分
- 围绕领域模型做设计沉淀

##### 发布基石：商家与门店

##### 导购核心：商品-类目-品牌-属性库模型的发布

##### 交易核心：SKU-库存模型的发布

##### 导购流程：搜索与详情浏览



### 第7章 社交图关系下的图数据库Neo4J解决方案

##### 图形数据结构存储如何支撑

图数据使用：

1. 关注、粉丝
2. 好友
3. 多维度关系

##### 动手使用neo4j

```shell
docker pull neo4j:latest
docker run -d --name neo4j -p 7474:7474 -p 7687:7687 --env NEO4J_AUTH=neo4j/neo4j123456 neo4j:latest
docker logs neo4j
http://localhost:7474/

CREATE(emp:Employee{id:1,name:"david",sal:1500})
CREATE(dept:Dept{id:1,name:"Accounting",location:"Shanghai"})
CREATE(dept:Dept{id:2,name:"Research",location:"Beijing"})
MATCH (n:Dept) where n.name="Accounting" return n.location,n.id,n.name LIMIT 25
Match (emp:Employee),(dept:Dept) create (bel)-[r:BELONG{"enterTime":"2021-10-10"}]
Match (emp:Employee),(dept:Dept) create (bel)-[r:BELONG{"enterTime":"2021-10-10"}]
Match (emp:Employee)->[b:BELONG]->(dept:Dept) where dept.name="Accounting" return emp,b,dept
Match (emp:Employee)->[b:BELONG]->(dept:Dept) where dept.name="Accounting" delete b
Match (n:Employee) where n.sal=32500 delete n
Match (n:Employee) return n

Match (n) detach delete n
CREATE (usr:User{id:1})
CREATE (usr:User{id:2})
CREATE (usr:User{id:3})
Match (usr:User) return usr;
Match (usr1:User),(usr2:User) where usr1.id=1 and usr2.id=2 CREATE (usr1)-[r:GUANZHU{time:"2022-10-01 10:00:01"}]->(usr2)
Match (usr1:User),(usr3:User) where usr1.id=1 and usr3.id=3 CREATE (usr1)-[r:GUANZHU{time:"2022-10-01 10:00:01"}]->(usr3)
# 查询用户1的关注列表
Match (usr1:User)-[r:GUANZHU]->(usr2:User) where usr1.id=1 return usr2
# 查询用户2的粉丝列表
Match (usr1:User)-[r:GUANZHU]->(usr2:User) where usr2.id=2 return usr1
Match (usr1:User)-[r:GUANZHU]->(usr2:User) where usr1.id=1 return usr2 order by usr2.userName limit 1

MATCH (n:User) RETURN n
# 加入用户节点
CREATE(n:User{id:$id,userName:$userName}) RETURN n
# 建立用户关注关系
Match (usr1:User),(usr2:User) where usr1.id=1 and usr2.id=3 CREATE (usr1)-[r:GUANZHU{time:"2022-10-01 10:00:01"}]->(usr2)
# 拉取用户的关注列表
Match (usr1:User)-[r:GUANZHU]->(usr2:User) where usr1.id=1 return usr2
# 拉取用户的粉丝列表
Match (usr1:User)-[r:GUANZHU]->(usr2:User) where usr2.id=1 return usr1
```

##### 关注粉丝能力设计

##### Neo4J分布式集群方案

1. 主从扩展 master slave

   Raft 协议竞争 leader 节点；core server、replication server

   core server：需要在写入操作的时候确保 N/2+1 的节点同步成功才算成功

   replication server：用于负责只读操作

   主从问题：可以无限制的扩展 replication server，解决读放大问题

2. 写入问题：分片



### 第9章 非关系型数据库mongoDB满足点赞评论场景

##### 点赞评论场景解析

##### MongoDB原理及优劣势

- 优势
  - 可建立二级索引且性能优越，文档式的存储结构BSON易扩展
- 劣势
  - 不支持事务，内存消耗大

##### 动手使用mongodb

```shell
docker pull mongo:latest
docker run -itd --name mongo -p 27017:27017 mongo --auth
docker exec -it xxx /bin/sh
mongosh
use admin
db.createUser({user:'admin',pwd:'123456',roles:[{role:'userAdminAnyDatabase', db:'admin'},"readWriteAnyDatabase"]})
db.auth('admin','123456')
show dbs
show collections;
use socialecom;
db.createCollections('student');
show dbs
show collections;
db.student.insertOne("name":"david","age":30,"gender":1)
db.student.find()
db.student.update({'_id':ObjectId("xxx")}, {$set:{'name':'mary'}})
db.student.find()
db.student.remove({'_id':ObjectId("xxx")})
db.student.find({'_id':ObjectId("xxx")})
db.col.createIndex({"name":1})
db.student.find({'_id':ObjectId("xxx")}).limit(1).skip(2).sort("age":1)


db.createCollections('like');
db.createCollections('remark');
db.like.createIndex({"messageId":1})
db.remark.createIndex({"messageId":1})
db.like.createIndex({"userId":1,"messageId":1},{unique:true})
```

##### 使用Java API实现点赞评论能力

实现方案

- 带条件查询且条件存储的数据库
- 满足高并发场景的读写能力
- 聚合脉冲归并结果

##### 削峰聚集能力的脉冲方案解决评论及点赞数量叠加问题

##### MongoDB分布式扩展
