#### SPS/PPS/Slice Header

1. H264 Profile

   对视频压缩特性的描述，Profile越高，就说明采用了越高级的压缩特性

2. H264 Level

   Level是对视频的描述，Level越高，视频的码率、分辨率、fps越高

   帧相关

   - 帧数：log2_max_frame_num_minus4
   - 参考帧数：max_num_ref_frames
   - 显示帧序号：pic_order_cnt_type

   帧率的计算

   ```c
   framerate = (float)(sps->vui.vui_time_scale)/(float)(sps->vui.vui_num_units_in_tick)/2;
   ```

3. PPS

4. Slice Header

   帧类型、GOP中解码帧序号、预测权重、滤波

#### H264分析工具

1. Elecard Stream Eye：https://www.elecard.com/products/video-analysis

   所有工具中最为强大的工具，可以分析H264码流

2. CodecVisa

   价格相对便宜些

3. 雷神开发的工具 

   SpecialVH264：分析H264码流

   videoeye：分析SPS/PPS

#### 实战H264编码

1. 打开设备
2. 打开编码器，设置参数
3. 从设备上采集的NV12数据，将转换NV12到YUV420P
4. 准备编码数据 AVFrame
5. H264编码

```c
AVCodecContext *enc_ctx = NULL;
// 打开设备时获取的 width, height
open_encoder(width, height, &enc_ctx);

/**
 * @brief 打开编码器
 * @param[in] width
 * @param[in] height
 * @param[out] enc_ctx
 */
static void open_encoder(int width, int height, AVCodecContext **enc_ctx){
    int ret = 0;
  	AVCodec *codec = NULL;
  	// 获取编码器
  	codec = avcodec_find_decoder_by_name("libx264");
  	if(!codec){
        printf("Codec libx264 not found\n");
        exit(1);
    }
  	// 获取编码器上下文
    *enc_ctx = avcodec_alloc_context3(codec);
    if(!enc_ctx){
        printf("Could not allocate video codec context!\n");
        exit(1);
    }
    // SPS/PPS 必须
    (*enc_ctx)->profile = FF_PROFILE_H264_HIGH_444;
    (*enc_ctx)->level = 50; //表示LEVEL是5.0
    // 设置分辫率 必须
    (*enc_ctx)->width = width;		//640
    (*enc_ctx)->height = height;	//480
    // GOP 必须
    (*enc_ctx)->gop_size = 250;
    (*enc_ctx)->keyint_min = 25;  //option 可选
    // 设置B帧数量
    (*enc_ctx)->max_b_frames = 3; //option 可选
    (*enc_ctx)->has_b_frames = 1; //option 可选
    // 参考帧的数量
    (*enc_ctx)->refs = 3;         //option 可选
    // 设置输入YUV格式
    (*enc_ctx)->pix_fmt = AV_PIX_FMT_YUV420P;
  	// 设置平均码率
    (*enc_ctx)->bit_rate = 1000000; //1000kbps
    // 设置帧率
    (*enc_ctx)->time_base = (AVRational){1, 25}; //帧与帧之间的间隔是time_base
    (*enc_ctx)->framerate = (AVRational){25, 1}; //帧率，每秒25帧
  	// 打开编码器
    ret = avcodec_open2((*enc_ctx), codec, NULL);
    if(ret<0){
        printf("Could not open codec: %s!\n", av_err2str(ret));
        exit(1);
    }
}
```

准备要编码的数据：

```c
#define V_WIDTH 640
#define V_HEIGTH 480
// 打开编码器
open_encoder(V_WIDTH, V_HEIGTH, &enc_ctx);
// 创建 AVFrame
AVFrame* frame = create_frame(V_WIDTH, V_HEIGTH);
// 创建编码后输出的Packet
AVPacket *newpkt = av_packet_alloc();
if(!newpkt){
    printf("Error, Failed to alloc avpacket!\n");
    goto __ERROR;
}

/**
 * @brief 创建 AVFrame
 * @param[in] width
 * @param[in] height
 * @return AVFrame*
 */
static AVFrame* create_frame(int width, int height){
    int ret = 0;
    AVFrame *frame = NULL;
    frame = av_frame_alloc();
    if(!frame){
        printf("Error, No Memory!\n");
        goto __ERROR;
    }
    // 设置参数
    frame->width = width;
    frame->height = height;
  	// x264要求的格式是YUV420
    frame->format = AV_PIX_FMT_YUV420P;
    // alloc inner memory
    ret = av_frame_get_buffer(frame, 32); // 按32位对齐
    if(ret < 0){
        printf("Error, Failed to alloc buffer for frame!\n");
        goto __ERROR;
    }
    return frame;
__ERROR:
    if(frame){
        av_frame_free(&frame);
    }
    return NULL;
}
```

NV12转YUV420P

```c
// ffplay -s 640x480 video.yuv
// read data from device
while((ret = av_read_frame(fmt_ctx, &pkt)) == 0 &&
      rec_status) {
    int i = 0;
    av_log(NULL, AV_LOG_INFO, "packet size is %d(%p)\n", pkt.size, pkt.data);
    //（宽 x 高）x (yuv420=1.5/yuv422=2/yuv444=3)
    // fwrite(pkt.data, 1, 460800, yuvoutfile);
    // fflush(yuvoutfile);
    // YYYYYYYYUVVU NV12
    // YYYYYYYYUUVV YUV420
    // 640 * 480 = 307200
    memcpy(frame->data[0], pkt.data, 307200); //copy Y data
    // 307200之后，是UV
    for(i=0; i < 307200/4; i++){
        // U
        frame->data[1][i] = pkt.data[307200+i*2];
        // V
        frame->data[2][i] = pkt.data[307201+i*2];
    }
    fwrite(frame->data[0], 1, 307200, yuvoutfile);
    fwrite(frame->data[1], 1, 307200/4, yuvoutfile);
    fwrite(frame->data[2], 1, 307200/4, yuvoutfile);
		// pts不能是随机值，会影响编码质量
    frame->pts = base++;
    encode(enc_ctx, frame, newpkt, outfile);

    av_packet_unref(&pkt); //release pkt
}
encode(enc_ctx, NULL, newpkt, outfile);
```

H264编码：

```c
static void encode(AVCodecContext *enc_ctx, AVFrame *frame,
                   AVPacket *newpkt, FILE *outfile){
    int ret = 0;
    if(frame){
        printf("send frame to encoder, pts=%lld", frame->pts);
    }
    // 送原始数据给编码器进行编码
    ret = avcodec_send_frame(enc_ctx, frame);
    if(ret < 0) {
        printf("Error, Failed to send a frame for enconding!\n");
        exit(1);
    }
    // 从编码器获取编码好的数据
    while(ret >=0) {
        ret = avcodec_receive_packet(enc_ctx, newpkt);
        // 如果编码器数据不足时会返回 EAGAIN,或者到数据尾时会返回 AVERROR_EOF
        if( ret == AVERROR(EAGAIN) || ret == AVERROR_EOF){
            return;
        } else if (ret <0){
            printf("Error, Failed to encode!\n");
            exit(1);
        }
        fwrite(newpkt->data, 1, newpkt->size, outfile);
        av_packet_unref(newpkt);
    }
}
```

#### x264参数分配

1. 预设值
   1. preset fast/slow
   2. tune：与质量相关
2. 帧相关参数
   1. keyint/min-keyint
   2. scenecut
   3. bframes
   4. ref：参考帧数量
   5. no-deblock/deblock
   6. no-cabac
3. 码流的控制
   1. Qp 关注量化器，比crf码流大且与bitrate/crf互斥
   2. Bitrate，关注码流，无法控制质量
   3. Crf，关注质量，默认是23，越低越好
   4. Qmin 默认为10
   5. Qmax 默认为51
   6. Qpstep 两帧之间量化器的最大变化，默认为4
4. 编码分析
   1. Partitions p8x8 b8x8 i4x4：宏块划分
   2. Me 运动评估算法、钻石、六边型
5. 输出
   1. SAR 设置输出的宽高比
   2. fps 帧率
   3. leve 设置输出规格

```shell
# -vsync 1 -async 1：音频和视频同步
# -i xxx.flv：处理的输入视频
# -b:v 200k：控制视频的码流是200k
# -maxrate 250k：最大码流250k
# -vcodec libx264：设置编码器
# -coder 1：使用cabac
# -refs 3：参考帧数量3
# -bf 5：B帧最大数量是5
# -flags +loop -deblock -1:-1：使用去块化的滤波器和参数
# -partitions i4x4+i8x8+p8x8+b8x8：宏块划分
# -me_method umh：运动估算算法
# -g 60：gop 60
# -keyint_min 30：最小30
# -qmin 0 -qmax 69：最小量化值0，最大量化值69
# -qdiff 2
# out.mp4 输出结果
ffmpeg -vsync 1 -async 1 -i xxx.flv
      -b:v 200k -maxrate 250k -bufsize 400k
      -pix_fmt yuv420p
      -vcodec libx264 -coder 1
      -refs 3 -bf 5
      -flags +loop -deblock -1:-1
      -partitions i4x4+i8x8+p8x8+b8x8 -me_method umh
      -g 60 -keyint_min 30
      -qmin 0 -qmax 69 -qdiff 2
      out.mp4
```

