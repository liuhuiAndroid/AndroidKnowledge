### JNI编译与运行

JNI：提供一种Java字节码调用C/C++的解决方案

```cmake
#将native-lib.cpp编译到动态库identity中
add_library(
        identity
        SHARED
        native-lib.cpp)
        
#在系统库中查找log->liblog.so
find_library(
        log-lib
        log)
        
#链接动态库，最终生成identity.so
target_link_libraries(
        identity
        #导入库文件，变成系统的环境变量
        opencv_java4
        #系统内置库
        ${log-lib}
        jnigraphics
        android)
```

```cpp
//extern "C"：把下面代码转换成C的代码，不写方法无法识别
extern "C"
JNIEXPORT void JNICALL
Java_com_face_identity_MainActivity_init(JNIEnv *env, jobject thiz, jstring model_) {
  	
}
```



### cmake原理详解与cmake编译流程机制

.cxx 下 metadata_generation_command.txt

```shell
                    Executable : /Users/sec/Library/Android/sdk/cmake/3.18.1/bin/cmake
arguments : 
-H/Users/sec/Documents/github-ndk/ndk-start/opencv-study/FaceIdentity/app/src/main/cpp
-DCMAKE_SYSTEM_NAME=Android
-DCMAKE_EXPORT_COMPILE_COMMANDS=ON
-DCMAKE_SYSTEM_VERSION=26
-DANDROID_PLATFORM=android-26
-DANDROID_ABI=armeabi-v7a
-DCMAKE_ANDROID_ARCH_ABI=armeabi-v7a
-DANDROID_NDK=/Users/sec/Library/Android/sdk/ndk/21.4.7075529
-DCMAKE_ANDROID_NDK=/Users/sec/Library/Android/sdk/ndk/21.4.7075529
-DCMAKE_TOOLCHAIN_FILE=/Users/sec/Library/Android/sdk/ndk/21.4.7075529/build/cmake/android.toolchain.cmake
-DCMAKE_MAKE_PROGRAM=/Users/sec/Library/Android/sdk/cmake/3.18.1/bin/ninja
-DCMAKE_LIBRARY_OUTPUT_DIRECTORY=/Users/sec/Documents/github-ndk/ndk-start/opencv-study/FaceIdentity/app/build/intermediates/cxx/Debug/165dk393/obj/armeabi-v7a
-DCMAKE_RUNTIME_OUTPUT_DIRECTORY=/Users/sec/Documents/github-ndk/ndk-start/opencv-study/FaceIdentity/app/build/intermediates/cxx/Debug/165dk393/obj/armeabi-v7a
-DCMAKE_BUILD_TYPE=Debug
-B/Users/sec/Documents/github-ndk/ndk-start/opencv-study/FaceIdentity/app/.cxx/Debug/165dk393/armeabi-v7a
-GNinja
-DANDROID_STL=c++_shared
jvmArgs : 


                    Build command args: []
                    Version: 2
```

生成so目录：/app/build/intermediates/cmake/debug/obj/armeabi-v7a

cmake编译需要原文件和CMakeLists.txt

cmake .执行编译

### JNI函数调用机制



### H264视频编码原理

```shell
ffmpeg -i input.mp4 -c:v copy -bsf:v h264_mp4toannexb -an out.h264
ffplay -stats -f h264 out.h264
# -stats　　　打印多个回放统计信息，包括显示流持续时间，编解码器参数，流中的当前位置，以及音频/视频同步差值。默认情况下处于启用状态，要显式禁用它则需要指定-nostats。
# -f fmt 　　　强制使用设置的格式进行解析。比如-f s16le
ffmpeg -i input.mp4 -acodec copy -vn output.aac
ffmpeg -i h265.mkv -vcodec hevc output.h265
```

H264 = Mepg4-avc

ITU-T：H264、H263、H262、H261、

ISO：Mepg1、Mepg2、Mepg4-avc

Google：VP8、VP9，主要用于视频通话

```java
MediaCodec.createEncoderByType("avc");
```

pts：视频播放时间

帧分隔符：0x00000001，不会和码流数据冲突，转义

SPS图像参数集：配置信息，编码方式帧率码率等

PPS：宽高信息，

帧类型：区分SPS、PPS、I帧，5位

哥伦布编码

*Elecard* *HEVC* Analyzer：专门分析h265



### 通过MediaCodec解析出完整帧技术

```java
    /**
     * 渲染画面
     */
    private void initSurface() {
        SurfaceView surface = (SurfaceView) findViewById(R.id.preview);
        final SurfaceHolder surfaceHolder = surface.getHolder();
        surfaceHolder.addCallback(new SurfaceHolder.Callback() {
            @Override
            public void surfaceCreated(@NonNull SurfaceHolder holder) {
                h264Player = new H264Player(
                        new File(Environment.getExternalStorageDirectory(), "out3.h264").getAbsolutePath(),
                        surfaceHolder.getSurface()
                );
                h264Player.play();
            }

            @Override
            public void surfaceChanged(@NonNull SurfaceHolder holder, int format, int width, int height) {
            }

            @Override
            public void surfaceDestroyed(@NonNull SurfaceHolder holder) {
            }
        });
    }
```

```java
public class H264Player implements Runnable {

    private String path;
    private MediaCodec mediaCodec;

    public H264Player(String path, Surface surface) {
        this.path = path;
        try {
            // "video/avc" - H.264/AVC video
            // "video/hevc" - H.265/HEVC video
            mediaCodec = MediaCodec.createDecoderByType("video/avc");
            // 设置解码参数
            // 实际项目中由 MediaExtractor 解析视频得到宽高
            MediaFormat mediaformat = MediaFormat.createVideoFormat("video/avc", 368, 384);
            // 设置帧率
            mediaformat.setInteger(MediaFormat.KEY_FRAME_RATE, 15);
            mediaCodec.configure(mediaformat, surface, null, 0);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void play() {
        mediaCodec.start();
        new Thread(this).start();
    }

    @Override
    public void run() {
        try {
            decodeH264();
        } catch (Exception e) {

        }
    }

    private void decodeH264() {
        byte[] bytes = null;
        try {
            // 文件加载到内存
            bytes = getBytes(path);
        } catch (Exception e) {
            e.printStackTrace();
        }
        // 内部的队列，不是每一个都可以用
        ByteBuffer[] inputBuffers = mediaCodec.getInputBuffers();
        // 开始索引
        int startIndex = 0;
        // 总字节数
        int totalSize = bytes.length;
        while (true) {
            if (totalSize == 0 || startIndex >= totalSize) {
                break;
            }
            // 寻找索引，需要跳过sps和pps
            int nextFrameStart = findByFrame(bytes, startIndex + 2, totalSize);
            MediaCodec.BufferInfo info = new MediaCodec.BufferInfo();
            // 查询哪一个bytebuffer能够用
            int inIndex = mediaCodec.dequeueInputBuffer(10000);
            if (inIndex >= 0) {
                // 当前有可用的 bytebuffer
                ByteBuffer byteBuffer = inputBuffers[inIndex];
                byteBuffer.clear();
                byteBuffer.put(bytes, startIndex, nextFrameStart - startIndex);
                mediaCodec.queueInputBuffer(inIndex, 0, nextFrameStart - startIndex, 0, 0);
                startIndex = nextFrameStart;
            } else {
                continue;
            }
            // 手动查询数据
            int outIndex = mediaCodec.dequeueOutputBuffer(info, 10000);
            if (outIndex >= 0) {
                try {
                    // 控制播放速度
                    Thread.sleep(33);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                mediaCodec.releaseOutputBuffer(outIndex, true);
                // 也可以不设置surface，直接获取解码数据
                // mediaCodec.getOutputBuffer(outIndex);
                // mediaCodec.releaseOutputBuffer(outIndex, false);
            } else {

            }
        }
    }

    /**
     * 寻找索引
     */
    private int findByFrame(byte[] bytes, int start, int totalSize) {
        for (int i = start; i < totalSize - 4; i++) {
            // 分隔符
            if (bytes[i] == 0x00 && bytes[i + 1] == 0x00 && bytes[i + 2] == 0x00 && bytes[i + 3] == 0x01) {
                return i;
            }
        }
        return -1;
    }

    /**
     * 文件加载到内存，只读取小文件
     */
    public byte[] getBytes(String path) throws IOException {
        InputStream is = new DataInputStream(new FileInputStream(path));
        int len;
        int size = 1024;
        byte[] buf;
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        buf = new byte[size];
        while ((len = is.read(buf, 0, size)) != -1)
            bos.write(buf, 0, len);
        buf = bos.toByteArray();
        return buf;
    }

}
```



### 录屏h264编码

```java

    private void initMediaCodec() {
        try {
            // 编码h264裸流
            mediaCodec = MediaCodec.createEncoderByType("video/avc");
            MediaFormat format = MediaFormat.createVideoFormat(MediaFormat.MIMETYPE_VIDEO_AVC,
                    540, 960);
            format.setInteger(MediaFormat.KEY_COLOR_FORMAT,
                    MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);
            format.setInteger(MediaFormat.KEY_FRAME_RATE, 15);
            format.setInteger(MediaFormat.KEY_BIT_RATE, 400_000);
            // 2S一个I帧
            format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 2);
            mediaCodec.configure(format, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);
            // // 这是 MediaCodec 提供的 surface
            final Surface surface = mediaCodec.createInputSurface();
            new Thread() {
                @Override
                public void run() {
                    mediaCodec.start();
                    // surface 与 MediaProjection 关联
                    mediaProjection.createVirtualDisplay("screen-codec",
                            540, 960, 1,
                            DisplayManager.VIRTUAL_DISPLAY_FLAG_PUBLIC,
                            surface, null, null);
                    MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();
                    while (true) {
                        // 源源不断的取出编码好的数据
                        int index = mediaCodec.dequeueOutputBuffer(bufferInfo, 100000);
                        if (index >= 0) {
                            ByteBuffer buffer = mediaCodec.getOutputBuffer(index);
                            byte[] outData = new byte[bufferInfo.size];
                            buffer.get(outData);
                            writeContent(outData);
                            writeBytes(outData);
                            mediaCodec.releaseOutputBuffer(index, false);
                        }
                    }
                }
            }.start();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void writeBytes(byte[] array) {
        FileOutputStream writer = null;
        try {
            // 打开一个写文件器，构造函数中的第二个参数true表示以追加形式写文件
            writer = new FileOutputStream(Environment.getExternalStorageDirectory() + "/codec.h264", true);
            writer.write(array);
            writer.write('\n');
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (writer != null) {
                    writer.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    public String writeContent(byte[] array) {
        char[] HEX_CHAR_TABLE = {
                '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
        };
        StringBuilder sb = new StringBuilder();
        for (byte b : array) {
            sb.append(HEX_CHAR_TABLE[(b & 0xf0) >> 4]);
            sb.append(HEX_CHAR_TABLE[b & 0x0f]);
        }
        Log.i(TAG, "writeContent: " + sb.toString());
        FileWriter writer = null;
        try {
            // 打开一个写文件器，构造函数中的第二个参数true表示以追加形式写文件
            writer = new FileWriter(Environment.getExternalStorageDirectory() + "/codec.txt", true);
            writer.write(sb.toString());
            writer.write("\n");
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (writer != null) {
                    writer.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return sb.toString();
    }
```



### H264 手写 SPS 解析

哥伦布编码：适合短数据编码

十进制转二进制

二进制转十进制



### H265编码原理原理与码流分析

H264：视频文件过大、解码速度过慢

H265投屏方式

Elecard HEVC Analyzer



### 答疑

camera采集原始数据，画面旋转90度



### 用H265实现低延时投屏

H265数据传输解码渲染

手机A录屏得到YUV数据，经过MediaCodec编码成h265数据，再通过socket方式传输到手机B



### H265版视频通话



### 音视频剪辑原理

MediaExtractor解压MP3，然后创建MediaCodec



### 音频合成

实现两个音频PCM实现混音

1. 音频编码原理高低字节区分
2. 如何分别调整混音后的音频大小
3. 每一个音频采样位数如何叠加



### 视频剪辑原理

MediaMuxer 视频封装容器

MediaExtractor 设置视频轨和音频轨



### 两个视频拼接

合成视频不需要编码



### Camera2与CameraX框架机制详解

Camera2与yuv通道合成nv12

Camera2保存h264码流和h265码流

Camera2推流

yuv420=nv12



### 直播推流之手写哔哩哔哩硬编码录屏推流

rtmp 和 rtsp 协议详解，rtmp 适合直播，rtsp 适合录屏

利用硬编码对原始帧进行h264编码

直播关键帧触发间隔，实现秒开技术

手写推流到B站的直播功能



### 音频直播推流

AudioRecord



### 直播服务器搭建与交叉编译原理

nginx

交叉编译：在一个平台上生成另一个平台上的可执行代码。

git 下载 x264源码



### X264集成与Camera推流



### 软编X264实现CameraX直播推流



### 音频编码与推流

faac编译，音频编码实现推流



### OpenGL程序运行机制



### OpenGL实现摄像头灰色滤镜



### OpenGL抖音录制滤镜视频

高斯模糊美颜



### 手写腾讯MMKV ，手把手带你理解MMKV如何突破IO瓶颈

SharedPreferences



### 手写腾讯MMKV，ProtuBuffer协议打造最优存储

C++线程锁与进程锁

哥伦布编码与ProtoBuffer编码区别与优势

手写ProtoBuffer编码版MMKV，实现存取功能



### 手写腾讯MMKV，mmkv 取值与存值



### OpenCV人脸定位

OpenCV官网：https://opencv.org/

OpenCV Github主页：https://github.com/opencv/opencv

OpenCV下载：https://opencv.org/releases/

OpenCV原理：LBP算法寻找特征点

OpenCV使用流程：

1. 准备训练集

   OpenCV mac进行训练，Android集成

2. 训练出模型存储的权重

3. OpenCV项目集成

   1. 下载SDK：opencv-4.6.0-android-sdk.zip

   2. 从sdk/native/libs/armeabi-v7a导入so

   3. 从sdk/native/jni/include/opencv2导入.h

   4. build.gradle添加配置

      ```groovy
      sourceSets{
          main{
             jniLibs.srcDirs = ['src/main/cpp/libs']
          }
      }
      
      defaultConfig {
          externalNativeBuild {
              cmake {
                cppFlags ''
                // 设置编译平台
                abiFilters 'armeabi-v7a'
              }
          }
          ndk {
            	abiFilters 'armeabi-v7a'
          }
      }
      ```

   5. 修改CMakeLists.txt

   6. java.lang.UnsatisfiedLinkError: dlopen failed: library "libc++_shared.so" not found

      ndk18以前用的gcc，ndk18以后用的clang，去除了libc++_shared.so，以前不需要配置，现在需要

      ```groovy
      externalNativeBuild {
          cmake {
              cppFlags ''
              // 设置编译平台
              abiFilters 'armeabi-v7a'
              // 配置远程下载libc++_shared.so
              arguments "-DANDROID_STL=c++_shared"
          }
      }
      ```

4. 加载模型，从 opencv/build/etc/lvpcascades/lbpcascade_frontalface.xml 加入到 assets

5. OpenCV模型训练

   OpenCV最新版本不带训练，下载OpenCV3.4.13带训练

   opencv/build/x64/vc15/bin/opencv_createsamples.exe 训练模型

6. OpenCV模型加载

   


### FFmpeg

视频压缩使用软解，大量手机不支持B帧编码，所以得通过FFmpeg来做

https://ffmpeg.org/download.html

```shell
# 下载ffmpeg
wget https://ffmpeg.org/releases/ffmpeg-snapshot.tar.bz2
tar ffmpeg-snapshot.tar.bz2
# 交叉编译，不需要最新的ndk
```

FFmpeg头文件需要加extern "C"



### FFmpeg万能音乐播放器

OpenSL ES 生产者消费者模式

C函数转成CPP函数需要强转

SoundTouch



### WebRTC



### 音视频面试



### cmake

Makefile：帮助我们管理编译项目；make运行会自动寻找Makefile

1. 若想要生成目标文件，会检查规则中的依赖是否存在，如果不存在，则寻找是否有完整的规则来生成该依赖条件
2. 会检查规则中的目标是否需要更新，必须先检查它所有依赖项，依赖中任意一个被更改，则目标必须更新
3. src=$(wildcard *.cpp)：找到当前目录下所有后缀为.cpp的文件，然后赋值给src
4. obj=$(patsubst %cpp,%o,$src)： 把src变量里所有后缀为.cpp的文件替换成.o文件

cmake：跨平台编译工具，可以输出makefile文件

1. 写CMakeList.txt里面用cmake语法写，会帮我们生成Makefile用于编译管理项目
2. 参考cmake实战安装cmake

shell：
